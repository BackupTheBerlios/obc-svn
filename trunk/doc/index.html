<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Documentación del raytracer</title>

<link rel="stylesheet" href="base.css" type="text/css"></head>
<body>
<div id="navcontainer">
<ul id="navlist">
<li id="active"><a href="#">Introducción</a></li>
<li><a href="desarrollo.html">Desarrollo</a></li>
<li><a href="html/index.html">Doc. Objc.</a></li>
<li id="finlista"><a href="http://developer.berlios.de" title="BerliOS Developer"><img src="http://developer.berlios.de/bslogo.php?group_id=9440" alt="BerliOS Developer Logo" border="0" height="32" width="124"></a></li>
</ul>
</div>
<div class="principal">
<h1>Introducción</h1>
<p>¿Que porqué estamos haciendo
ésto? Uff!! pues es largo de contar, pero allá voy. Yo soy Fernando
Arroba (Notxor) y lo que voy a contaros son todo percepciones
subjetivas, nada que ver con la realidad ;-).</p>
<div>
<div>
<h2 class="titulo2">Haciendo un poco de historia.</h2>
</div>
<p>Hace unos años (por el 2003 ó 2004), Javier
Belanche, Anexus y yo iniciamos un proyecto que al final quedó
en
nada. Consistía en programar un <i>raytracer</i>
más con
la intención de aprender cómo funciona un raytracer que hacer un
raytracer maravilloso. El reto comenzó intercambiando documentación a
través de la red y también en papel (que Javier nos envió a casa) todo
en perfecto inglés. Durante días utilizamos el canal de IRC de
BlenderAdictos3D para comunicarnos y contarnos lo que descubríamos.</p>
<p>El otro reto era utilizar como lenguaje de desarrollo C (no
C++) sino el más puro y duro C, pero orientado a objetos.
Efectivamente, llegamos a la conclusión que la programación orientada a
objetos es una <i>orientación</i>
independientemente del lenguaje que se utilice. Recuerdo que en
aquellos días parí un par de estructuras de listas enlazadas con <span style="font-family: monospace;">struct</span> y <span style="font-family: monospace;">void*</span> a los que
luego había que hacer <span style="font-family: monospace;">cast</span>
y esas cosas. Eso nos ocupó varios días y quitando aquél código que se
escribió nunca más se supo del proyecto. Sin embargo, quedó en mí el
deseo frustrado de aprender cómo funciona un raytracer, algo que
teóricamente sé, porque he estudiado todo lo que ha caído en mis manos
sobre el tema, pero que quiero llevar a la práctica. Así, un buen día
decidí ponerme a programar un raytracer; empecé sólo y se me unió Jaume
Singla (Dracks).</p>
<p>Sin embargo, aún habiendo pasado mucho tiempo,
quiero dedicarle estas líneas tanto a J.B. como a Anexus, mis
compañeros de entonces, y con los que se inició la inquietud de hacer
un raytracer.</p>
<div>
<h2 class="titulo2">El lenguaje de programación</h2>
</div>
<p>La primera decisión que tomar es el lenguaje que utilizaremos.
En esta decisión entran a jugar tanto los aspectos prácticos y
objetivos de rendimiento, como las apreciaciones subjetivas. Si tenemos
en cuenta el rendimiento debemos eliminar la mayoría de los lenguajes
modernos, en gran parte interpretados. Por ello se caen de la lista
lenguajes como Python o Ruby (o incluso smalltalk), que se encuentran
entre mis favoritos; aunque también son descartados otros como Java,
que no termina de convencerme. Lo mismo le ocurre a C#.</p>
<p>Puesto que sólo nos quedan los lenguajes compilados hay que
hacer otras consideraciones. Lo primero, y siguiendo con los motivos
prácticos, deberíamos elegir un lenguaje multiplataforma que nos
permitiera desarrollar en, al menos, los tres grandes sistemas
operativos (win, mac, linux), y otros posibles como BeOS (Haiku) y
similares. Quizá con estas consideraciones el lenguaje mayormente
seleccionado sea C++, sin embargo, no lo será en este caso.</p>
<div>
<h3 class="titulo3">¿Por qué no utilizar C++?</h3>
</div>
<p>Nunca me gustó. Me parece una amalgama de ladrillos pegados
con chicle, un mal parche para que C esté orientado a objetos. Tiene a
su favor su velocidad de ejecución y lo extendido que está. De hecho es
el lenguaje más utilizado para computación gráfica, especialmente en 3D
y juegos. Puede utilizar un
montón de librerías y en ese sentido sería más fácil de desarrollar el
raytracer. Pero no me gusta y ésto, claro está, es una de las
apreciaciones subjetivas de las que hablaba antes.</p>
<p>Por tanto, si la decisión es no utilizar C++ la alternativa
que nos viene a la cabeza de manera inmediata, es retomar el viejo
proyecto de programar el raytracer en C. &nbsp;Sin embargo, ya tuve
experienza<!--Habría que mirar la forma de sustituir los paréntesis con el guión que se utiliza más correctamente en castellano.-->
(y no demasiado grata) del intento de hacer una programación orientada
a objetos (POO) con C. Y la POO es algo de lo que no puedo prescindir,
especialmente desde que caí en smalltalk.</p>
<div>
<h3 class="titulo3">Objective-C</h3>
</div>
<p>Es otra posibilidad. Igual que C++ triunfa en el mundo del PC,
existe otro intento de evolucionar el C hacia la POO, el <i>Objective-C</i>.
Next desarrolló su sistema operativo, posteriormente comprado por Apple
y base del actual MacOS, con un lenguaje híbrido entre c y smalltalk.</p>
<p>Objective-C (Objc) promete una velocidad similar a C++
&nbsp;y una mayor sencillez. Sigue siendo compatible con C y puede
trabajar con librerías de C. También con las librerías de C++ desde la
versión 2.95 de las herramientas GCC. La sintaxis es una mezcla curiosa
de lenguajes y el smalltalk le da una flexibilidad increíble al rígido
lenguaje c. Muchas de las decisiones que otros lenguajes toman en
tiempo de compilación, Objc las aplaza hasta la ejecución, sin que haya
una significativa pérdida de velocidad en la ejecución. Me encanta el
trabajar con los protocolos, las categorías o los selectores;
facilidades que nos proporcionan unas poderosas herramientas a la hora
de programar.</p>
<p>Sin embargo, también presenta algunos problemas. Aunque la
gestión de módulos (de hecho la extensión de Objc en los ficheros de
código es .m, de módulo) es correcta y menos compleja que la de C,
sigue necesitando ficheros de cabecera y directivas del precompilador
para importarlos. Echo de menos la sobrecarga de operadores y los
espacios de nombres para evitar la colisión de los mismos.</p>
<div>
<h3 class="titulo3">El lenguaje D</h3>
</div>
<p>El D es un lenguaje relativamente moderno, de mediados de los
años
90 del siglo pasado y su principal problema quizá sea su juventud.
Según sus autores el D aspira a sustituir al C++ y promete unas
prestaciones iguales a él. Sin embargo, la <i>guerra interna</i>
entre dos
librerías por hacerse con el estándar, la falta de una librería gráfica
estable con la que trabajar y la inmadurez de algunas de sus librerías
hacen que el lenguaje no termine de asentarse entre los programadores.</p>
<p>Sin embargo, y puesto que es un lenguaje moderno, permite
entre otras cosas el desarrollo por contrato (<span style="font-family: monospace;">in {}</span>, <span style="font-family: monospace;">out {}</span>, <span style="font-family: monospace;">testcase{}</span>...),
tiene recolección de basura automatizada aunque se puede desactivar y
realizar a mano. Aunque los arrays&nbsp;son &nbsp;poco más que
un poco de sintaxis para ocultar un puntero, al menos pueden ser
dinámicos y concatenarse, permiten slices tipo <span style="font-family: monospace;">loQueSea[4..7]</span>.
Otros puntos a favor es la generación de documentación incluída en el
mismo lenguaje (algo parecido al javaDoc, con Objective-C utilizamos
Doxygen),&nbsp;la desaparición de las directivas del preprocesador,
o su propio sistema de compilación que hace que <span style="font-family: monospace;">make</span> sea una
herramienta obsoleta.</p>
<p>Todas estas características hacen que me apetezca conocer un
poco más de este lenguaje.</p>
</div>
</div>
</body></html>